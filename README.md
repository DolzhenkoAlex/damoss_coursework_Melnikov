МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ РОССИЙСКОЙ ФЕДЕРАЦИИ 
РОСТОВСКИЙ ГОСУДАРСТВЕННЫЙ ЭКОНОМИЧЕСКИЙ УНИВЕРСИТЕТ (РИНХ)
 
ФАКУЛЬТЕТ КОМПЬЮТЕРНЫХ ТЕХНОЛОГИЙ И ИНФОРМАЦИОННОЙ БЕЗОПАСНОСТИ 
 
Кафедра Информационных систем и прикладной информатики 
 
 
 
КУРСОВОЙ ПРОЕКТ
«Информационная подсистема магазина компьютерной техники» 
 
 
Выполнил
студент группы ПИ-331                                                                А. И. Мельников
                            

Направление                     09.03.03 – «Прикладная информатика»
Профиль                            09.03.03.01 – «Прикладная информатика в экономике»
 
 
Руководитель курсового
проекта
д.э.н., Доцент, Профессор кафедры                                              А. И. Долженко
				       
                 
 
 








  
Ростов-на-Дону, 2023




___________________ 
Задание на курсовой проект.
Разработать Java приложение на базе платформы Java Spring для информационной системы, в соответствии с вариантом, определенным преподавателем. Информационная система должна представлять веб-приложение для обработки информации с моделями данных, которые должны храниться в базе данных PostgreSQL. Веб-приложение должно включать: 
1.	Главную страницу с заголовком приложения и ссылками для перехода на страницы обработки информации по каждой модели.
2.	На страницах обработки информации для модели данных должны быть предусмотрены возможности вывода данных из модели, ввода новых данных, редактирования и удаления данных.
3.	Для разработанного веб-приложения необходимо создать модульные и интеграционные тесты.
4.	Аутентификацию пользователей, защиту веб-запросов и безопасность на уровне методов. 
Этапы выполнения курсового проекта: 
1.	Создание базы данных и наполнения её тестовыми данными. 
2.	Создание главной страницы веб-приложения. 
3.	Создание страниц для работы с моделями, не связанными внешними ключами с другими моделями. 
4.	Создание страниц для работы с моделями, связанными внешними ключами с другими моделями. 
5.	Создание модульных и интеграционных тестов. 
6.	Настройка аутентификации пользователей, защита веб-запросов и безопасность на уровне методов.
7.	Оформление пояснительной записки по курсовому проекту. 
Оглавление
Введение.	4
Выполнение работы.	5
Проектирование базы данных.	5
Разработка приложения.	7
Написание Liquibase скриптов.	7
Разработка слоя сущностей.	8
Разработка слоя доступа к данным.	9
Разработка слоя бизнес-логики.	10
Разработка MVC-контроллеров.	11
Разработка HTML-шаблонов.	12
Разработка REST-API.	13
Защита api-запросов. Реализация аутентификации по JWT-токену.	14
Тестирование приложения.	15
Тестирование слоя доступа к данным.	15
Тестирование слоя бизнес-логики.	16
Тестирование контроллеров.	17
Заключение.	18
Приложения	19
Приложение 1. Liquibase скрипты.	19
Приложение 2. Классы-сущности.	23
Приложение 3. JPA-репозитории.	27
Приложение 4. Классы слоя бизнес-логики.	28
Приложение 5. MVC-контроллеры.	31
Приложение 6. Шаблоны.	35
Приложение 7. DTO-классы.	36
Приложение 8. Классы REST-контроллеры.	38
Приложение 9. Конфигурация для аутентификации через JWT-токен.	40
Приложение 10. Тестирование слоя доступа к данным.	44
Приложение 11. Тестирование слоя бизнес-логики.	47
Приложение 12. Тестирование контроллеров.	53
Приложение 13. Результат выполнения работы.	68

Введение.
Целью курсовой работы является проектирование и реализация информационной подсистемы компьютерного магазина.
В ходе выполнения работы необходимо решить следующие задачи:
1.	Разработка базы данных с использованием системы управления базами данных PostgreSQL.
2.	Создание клиентской части приложения с использованием веб-фреймворка Spring MVC.
3.	Реализация бизнес-логики приложения с использованием фреймворка Spring Data JPA.
4.	Тестирование разработанной системы с помощью инструментов JUnit и AssertJ.
5.	Оптимизация производительности системы с использованием ORM Hibernate и механизма миграции баз данных Liquibase.
6.	Разработка REST-API для взаимодействия с внешними системами.
7.	Реализация авторизации и аутентификации пользователей через JWT-токен.
Результатом выполнения курсовой работы станет информационная подсистема компьютерного магазина, способная выполнять стандартные операции создания, чтения, обновления и удаления данных о товарах, клиентах и заказах, а также предоставлять удобный пользовательский интерфейс.
 
Выполнение работы.
Проектирование базы данных.
База данных состоит из пяти таблиц: 
1.	Пользователи (computer_shop_user);
2.	Товары (computer_shop_product);
3.	Персональные компьютеры (computer_shop_personal_computer);
4.	Ноутбуки (computer_shop_laptop);
5.	Принтеры (computer_shop_printer).
В таблице 1 представлены атрибуты computer_shop_user:
Название	Тип данных	Пояснение
id	UUID	Идентификатор 
username	varchar(50)	Уникальное имя
email	varchar(255)	Адрес электронной почты
password	varchar(255)	Пароль
role	varchar(20)	Роль
В таблице 2 представлены атрибуты computer_shop_product:
Название	Тип данных	Пояснение
id	UUID	Идентификатор
model	varchar(100)	Название модели
price	decimal	Стоимость
product_type	varchar(30)	Тип продукта
В таблице 3 представлены атрибуты computer_shop_personal_computer :
Название	Тип данных	Пояснение
product_id	UUID	Индентификатор товара
processor_frequency	float	Быстродействие процессора
ram_volume	decimal	Объем оперативной памяти
hard_disk_memory_volume	integer	Объем памяти внутреннего накопителя
cd_type	varchar(50)	Тип внутреннего накопителя
	
В таблице 4 представлены атрибуты computer_shop_laptop:
Название	Тип данных	Пояснение
product_id	UUID	Индентификатор товара
processor_frequency	float	Быстродействие процессора
ram_volume	decimal	Объем оперативной памяти
hard_disk_memory_volume	integer	Объем памяти внутреннего накопителя
monitor_diagonal_size	float	Размер диагонали монитора
	В таблице 5 представлены атрибуты computer_shop_printer:
Название	Тип данных	Пояснение
product_id	UUID	Индентификатор товара
is_coloured	boolean	True - цветной, false - чб
printer_type	varchar(50)	Тип печатающего устройства
	На рисунке 1 представлена схема базы данных:
 
Рисунок 1 – схема базы данных приложения. 
Разработка приложения.
Написание Liquibase скриптов.
Liquibase - это инструмент для управления изменениями в базе данных, который используется для внедрения, управления и отслеживания изменений в структуре базы данных и данных. Он позволяет разработчикам программного обеспечения автоматизировать процесс внесения изменений в базу данных, минимизируя ошибки и упрощая процесс развертывания. Liquibase поддерживает различные системы управления базами данных, такие как MySQL, PostgreSQL, Oracle и другие.
Правила выполнения скриптов указываются в файле db.changelog.yaml, который хранится в пакете resources/db/changelog. В файле указываются правила выполнения liquibase-скриптов. Поддерживается использование нескольких файлов для разделения на профили.
Liquibase-скрипты хранятся в пакете resources/db/changelog/changeset. В коммерческой разработке используется разделение версий скриптов по пакетам. 
Возможные варианты форматов для Liquibase скриптов включают XML, YAML, CSV и SQL. В рамках выполнения работы был выбран формат SQL как наиболее простой и привычный для написания. 
Содержимое всех luiqubase-скриптов представлено в приложении 1. На рисунке 2 представлено содержимое файла db.changelog.yaml:
  
Рисунок 2 – содержимое db.changelog.yaml . 
Разработка слоя сущностей.
В контексте Spring, "Entity" обычно относится к классу, который представляет данные в базе данных. Это POJO (Plain Old Java Object), который содержит поля, соответствующие столбцам в таблице базы данных, и аннотации, указывающие на то, как эти данные должны быть сохранены и извлечены. Программный код классов-сущностей представлен в приложении 2.
 
Разработка слоя доступа к данным.
Разрабатываемое приложение имеет простоую структуру базы данных и не содержит сложной бизнес-логики, требующей сложных SQL-запросов, поэтому в качестве слоя доступа к данным используются JPA-репозитории.
JPA-репозиторий в Spring Framework представляет собой компонент, который обеспечивает доступ к данным в базе данных через Java Persistence API (JPA). JPA является спецификацией API, которая позволяет сохранять Java-объекты в базе данных в удобном виде. Она предоставляет платформо-независимый объектно-ориентированный язык запросов Java Persistence Query Language (JPQL), который используется для написания запросов к сущностям, хранящимся в реляционной базе данных.
Одним из главных преимуществ использования JPA-репозиториев является краткость кода. Программный код интерфейсов репозиториев представлен в приложении 3.
 
Разработка слоя бизнес-логики.
Вынесение бизнес-логики в отдельный слой имеет несколько преимуществ:
1.	Модульность и повторное использование: Бизнес-логика может быть реализована в отдельных компонентах, которые могут быть повторно использованы в различных частях приложения.
2.	Тестируемость: Отделение бизнес-логики упрощает тестирование, поскольку тесты могут быть написаны для каждого компонента отдельно, не затрагивая остальную часть системы.
3.	Масштабируемость: При необходимости расширения функциональности или добавления новых функций, изменение бизнес-логики не влияет на другие слои системы.
4.	Управление изменениями: Изменения в бизнес-правилах легче внедрять, если они изолированы в отдельном слое.
5.	Безопасность: Бизнес-логика часто включает правила безопасности, которые должны быть строго контролируемыми. Вынос этих правил в отдельный слой помогает обеспечить их централизованное управление и контроль.
6.	Производительность: Компоненты бизнес-логики могут быть оптимизированы независимо от других частей системы, что улучшает общую производительность приложения.
7.	Разделение ответственности: Разработчики, специализирующиеся на бизнес-логике, могут сосредоточиться на создании и поддержке компонентов бизнес-логики, в то время как другие разработчики могут заниматься другими аспектами системы.
Программный код классов-сервисов представлен в приложении 4. 
Разработка MVC-контроллеров.
Контроллеры в модели Spring MVC отвечают за обработку входящих запросов и координацию взаимодействия между моделями и представлениями. Они являются точкой входа для бизнес-логики и отвечают за выполнение операций создания, чтения, обновления и удаления данных.
Когда запрос приходит в Spring MVC приложение, DispatcherServlet определяет, какой контроллер должен обработать этот запрос, основываясь на конфигурации @RequestMapping. Затем контроллер выполняет необходимые действия, такие как получение данных из модели, выполнение бизнес-логики и подготовка модели данных для представления. После этого контроллер возвращает объект View, который отвечает за отображение модели в представление, такое как HTML-страница, JSON-ответ или другой формат.
Контроллеры в Spring MVC помогают поддерживать чистоту и модульность кода, отделяя бизнес-логику от представления и обеспечивая легкость тестирования благодаря инверсии контроля.
Программный код классов MVC-контроллеров представлен в приложении 5.
 
Разработка HTML-шаблонов.
Для слоя отображения данных был использован шаблонизатор Thymeleaf. Он позволяет отделить логику приложения от представления, что упрощает разработку и поддержку веб-приложений. 
Thymeleaf основан на HTML, что делает его легким для понимания и использования дизайнерами и разработчиками. Шаблоны Thymeleaf могут включать в себя разметку HTML и специальные теги Thymeleaf для вставки динамического контента. 
Thymeleaf также поддерживает смешанные выражения, позволяющие использовать как синтаксис XML, так и JavaScript. 
	Программный код шаблонов представлен в приложении 6. 
Разработка REST-API.
REST-API - это архитектура, которая использует HTTP-методы для взаимодействия между клиентами и серверами. REST API позволяет передавать данные в формате JSON или XML. REST API обеспечивает надежность, производительность, масштабируемость и прозрачность системы взаимодействия, а также упрощает интерфейсы и облегчает внесение изменений.
REST контроллеры в Spring представляют собой компоненты, которые обрабатывают HTTP-запросы в соответствии с принципами RESTful архитектуры. Они используются для разделения логики обработки различных HTTP запросов. REST контроллеры в Spring позволяют разработчикам создавать веб-сервисы, которые легко масштабируются и обмениваются данными с другими системами. Программный код классов-контроллеров представлен в приложении 8
При проектировании REST-контроллера был использован шаблон проектирования DTO (Data Transfer Object), используемый для передачи данных между подсистемами приложения. Он предназначен для сериализации и передачи данных между различными компонентами системы, не содержа при этом какого-либо поведения. Используется для передачи данных между клиентами и серверами, избегая прямого подключения к базе данных.
 Для преобразования объектов DTO в Entity используется Mapstruct - инструмент для генерации кода, который автоматически создает методы для преобразования объектов между собой. Он использует аннотации для определения правил преобразования и позволяет разработчику избежать ручного написания большого количества кода. MapStruct может значительно ускорить процесс разработки и уменьшить количество ошибок, связанных с ручным написанием кода преобразования.
Программный код DTO-классов представлен в приложении 7.  
Защита api-запросов. Реализация аутентификации по JWT-токену.
JSON Web Token (JWT) - это стандарт для создания токенов доступа, основанный на формате JSON. Он используется для передачи данных для аутентификации в клиент-серверных приложениях. Токены создаются сервером, подписываются секретным ключом и передаются клиенту, который в дальнейшем использует данный токен для подтверждения подлинности аккаунта. JWT токены обеспечивают безопасность и целостность данных, а также упрощают процесс аутентификации и авторизации.
Для реализации аутентификации по JWT-токену необходимо выполнить следующие действия:
1.	Создать конфигурационный класс. В этом классе создать методы, помеченные аннотацией Bean и возвращающие объекты SecurityFilterChain, AuthenticationProvider, PasswordEncoder и AuthenticationManager.
2.	Создать класс JwtTokenUtil, который будет отвечать за генерацию и валидацию JWT токенов.
3.	Создать класс AuthenticationService, отвечающие за создание новых пользователей и аутентификацию существующих.
4.	В контроллере, который обрабатывает аутентификацию, использовать метод generateToken для создания JWT токена и метод validateToken для проверки его валидности.
Вся необходимая конфигурация представлена в приложении 9.


  
 
Тестирование приложения.
Тестирование слоя доступа к данным.
Для тестирования приложения использовались библиотеки JUnit и AssertJ - инструменты для автоматизированного тестирования программного обеспечения. 
JUnit - это библиотека для Java, которая используется для написания модульных тестов. Она позволяет разработчикам создавать тестовые сценарии, которые проверяют поведение и состояние тестируемого модуля. 
AssertJ - это библиотека для Java, которая предоставляет набор утверждений для проверки условий в тестах. Она упрощает написание и чтение тестов, делая их более понятными и легкими для поддержки. Оба инструмента являются частью семейства фреймворков xUnit, которые основаны на SUnit, разработанном для языка программирования Smalltalk.
 В тестах слоя доступа к данным важно проверить корректность работы написанного запроса: добавляется нужный объект со всеми связями, фильтрация выполняется корректно, удаляются только нужные объекты и т.д. 
	Программный код тестов представлен в приложении 10. 
Тестирование слоя бизнес-логики.
При тестировании сервисного слоя Spring приложения, важно проверить следующие аспекты:
1.	Проверка бизнес-логики: Убедитесь, что сервисы корректно реализуют бизнес-логику приложения, включая логику обработки данных, валидацию, вычисления и бизнес-правила.
2.	Проверка взаимодействия с репозиториями: Сервисы корректно взаимодействуют с репозиториями данных, включая операции создания, чтения, обновления, удаления и транзакции.
3.	Проверка безопасности: Сервисы корректно обрабатывают аутентификацию и авторизацию, а также предотвращают возможные атаки, такие как SQL-инъекции и XSS.
4.	Проверка интеграции с другими компонентами: Убедитесь, что сервисы корректно взаимодействуют с другими компонентами приложения, такими как контроллеры и внешние системы.
Программный код тестов представлен в приложении 11.
 
Тестирование контроллеров.
При тестировании Spring контроллеров, важно проверить следующие аспекты:
1.	Проверка URL-адресов: К обрабатывает запросы к правильным URL-адресам. 
2.	Проверка параметров запроса: Контроллер корректно обрабатывает параметры запроса. 
3.	Проверка бизнес-логики: Контроллер корректно реализует бизнес-логику приложения. 
4.	Проверка ответов: Контроллер возвращает правильные ответы в зависимости от типа запроса. Это может включать проверку HTTP-статусов, формата данных и содержимого ответов.
5.	Проверка безопасности: Контроллер корректно обрабатывает безопасность, включая аутентификацию пользователей, проверку прав доступа и защиту от CSRF-атак.
6.	Проверка интеграции: Если контроллер взаимодействует с другими системами или сервисами, необходимо убедиться, что интеграция работает корректно. Это может включать тестирование взаимодействия с базами данных, веб-сервисами и другими системами.
7.	Проверка исключений: Контроллер корректно обрабатывает исключения и возвращает соответствующие HTTP-статусы и сообщения об ошибках.
Программный код тестов представлен в приложении 12.
 
Заключение. 
Разработанная информационная подсистема компьютерного магазина успешно выполняет свои функции. Система основана на использовании актуальных технологий разработки программного обеспечения: Java в качестве основного языка программирования, фреймворк Spring как гибкую и мощную платформу для разработки web-приложений, Postgresql как надежную систему управления базами данных, а также набор инструментов для тестирования, таких как junit и assertj, ORM-фреймворк hibernate для упрощения работы с базой данных. Кроме того, в системе используется liquibase для управления изменениями в схеме базы данных. Помимо этого, реализация REST-API вместе с авторизацией посредством JWT-токенов гарантирует безопасность и удобство при взаимодействии с другими системами. 
Результат выполнения работы представлен в приложении 13
